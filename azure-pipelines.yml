# 触发器：只在推送到 master 分支时自动构建
trigger:
- master

# PR 触发：只有 PR 到 master 分支时才构建
# 重要：只有已合并的PR才会执行完整的构建和Release流程
# 未合并的PR会在第一步被拦截并停止执行
pr:
- master

# 使用自托管代理池，加快 CI/CD 速度
pool:
  name: 'SenparcOpenSource'

variables:
  - group: NcfGitHubTokenVariableGroup
  - name: solution
    value: '**/NCF.sln'
  - name: templateBuild
    value: '**/NCF.Template.sln'
  - name: webProject
    value: 'src/back-end/Senparc.Web/Senparc.Web.csproj'
  - name: buildConfiguration
    value: 'Release'
  - name: NUGET_PACKAGES
    value: $(Agent.ToolsDirectory)/nuget/packages
  - name: buildId
    value: '$(Build.BuildId)'

jobs:
- job: BuildAndRelease
  pool:
    name: 'SenparcOpenSource'
  # 允许脚本访问OAuth token以便调用Azure DevOps REST API
  # 注意：需要在Pipeline设置中启用"Allow scripts to access the OAuth token"选项
  variables:
    - name: System.AccessToken
      value: $(System.AccessToken)
  steps:
    # 🔒 第一步：检查构建类型和授权 (支持 PR 构建和合并后构建)
    - task: PowerShell@2
      displayName: '🔒 Check Build Type and Authorization (Critical Gate)'
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "========================================"
          Write-Host "🔒 CRITICAL GATE: BUILD TYPE & AUTH CHECK"
          Write-Host "========================================"
          Write-Host ""
          Write-Host "📋 检查条件：支持2种构建类型"
          Write-Host "   1. PullRequest: PR 构建（合并前）"
          Write-Host "   2. IndividualCI: 合并后构建（推送到 master）"
          Write-Host ""
          
          $buildReason = "$(Build.Reason)"
          $sourceBranch = "$(Build.SourceBranch)"
          
          Write-Host "=== 构建信息 ==="
          Write-Host "Build.Reason: $buildReason"
          Write-Host "Build.SourceBranch: $sourceBranch"
          Write-Host ""
          
          # 检查构建类型：支持 PullRequest 或 IndividualCI (master分支)
          if ($buildReason -eq "PullRequest") {
              Write-Host "🔍 检测到 PR 构建，准备检查 GitHub PR 状态..."
              # 对于 PR 构建，继续原有的 GitHub API 检查逻辑
          } elseif ($buildReason -eq "IndividualCI" -and $sourceBranch -eq "refs/heads/master") {
              Write-Host "✅ 检测到 master 分支的合并后构建"
              Write-Host "   这是 PR 合并后触发的构建，允许继续"
              Write-Host ""
              Write-Host "✨ 跳过 PR 状态检查，直接进入构建流程..."
              Write-Host "========================================"
              return  # 直接通过，不需要额外检查
          } else {
              Write-Host "❌ GATE FAILED: 不支持的构建类型"
              Write-Host "   Build.Reason: $buildReason"
              Write-Host "   Build.SourceBranch: $sourceBranch"
              Write-Host "   支持的类型:"
              Write-Host "   - PullRequest (任何目标分支的 PR)"
              Write-Host "   - IndividualCI + refs/heads/master (合并到 master 后的构建)"
              Write-Host ""
              Write-Host "🚫 停止执行：只允许支持的构建类型"
              Write-Host "##vso[task.logissue type=error]Pipeline stopped: Unsupported build type"
              Write-Host "##vso[task.complete result=Failed]"
              exit 1
          }
          
          # 检查PR ID是否存在
          $prId = $env:SYSTEM_PULLREQUEST_PULLREQUESTID
          if ([string]::IsNullOrEmpty($prId)) {
              Write-Host "❌ GATE FAILED: 无法获取PR ID"
              Write-Host "   SYSTEM_PULLREQUEST_PULLREQUESTID: '$prId'"
              Write-Host ""
              Write-Host "🚫 停止执行：PR信息不完整"
              Write-Host "##vso[task.logissue type=error]Pipeline stopped: PR ID not available"
              Write-Host "##vso[task.complete result=Failed]"
              exit 1
          }
          
          Write-Host "✅ 基础检查通过："
          Write-Host "   ✓ 这是一个PR构建"
          Write-Host "   ✓ PR ID: $prId"
          Write-Host ""
          
          # 使用GitHub REST API检查PR状态 (因为代码托管在GitHub，不是Azure DevOps)
          Write-Host "🔍 正在检查GitHub PR合并状态..."
          try {
              # 获取GitHub PR编号 (不同于Azure DevOps PR ID)
              $githubPrNumber = $env:SYSTEM_PULLREQUEST_PULLREQUESTNUMBER
              if ([string]::IsNullOrEmpty($githubPrNumber)) {
                  Write-Host "❌ GATE FAILED: 无法获取GitHub PR编号"
                  Write-Host "   SYSTEM_PULLREQUEST_PULLREQUESTNUMBER: '$githubPrNumber'"
                  Write-Host ""
                  Write-Host "🚫 停止执行：GitHub PR信息不完整"
                  Write-Host "##vso[task.logissue type=error]Pipeline stopped: GitHub PR number not available"
                  Write-Host "##vso[task.complete result=Failed]"
                  exit 1
              }
              
              # GitHub API端点
              $apiUrl = "https://api.github.com/repos/NeuCharFramework/NCF/pulls/$githubPrNumber"
              Write-Host "   GitHub API URL: $apiUrl"
              Write-Host "   GitHub PR Number: $githubPrNumber"
              
              $headers = @{
                  "Authorization" = "token $($env:GH_TOKEN)"
                  "Accept" = "application/vnd.github.v3+json"
                  "User-Agent" = "Azure-DevOps-Pipeline"
              }
              
              $response = Invoke-RestMethod -Uri $apiUrl -Headers $headers -Method GET
              
              $prState = $response.state
              $prMerged = $response.merged
              $prTitle = $response.title
              $prMergedAt = $response.merged_at
              
              Write-Host ""
              Write-Host "📊 GitHub PR详细信息："
              Write-Host "   PR标题: '$prTitle'"
              Write-Host "   PR状态: '$prState'"
              Write-Host "   是否已合并: $prMerged"
              if ($prMergedAt) {
                  Write-Host "   合并时间: $prMergedAt"
              }
              Write-Host ""
              
              # 检查PR是否已关闭并成功合并
              if ($prState -ne "closed") {
                  Write-Host "❌ GATE FAILED: PR尚未关闭"
                  Write-Host "   当前状态: '$prState'"
                  Write-Host "   要求状态: 'closed'"
                  Write-Host ""
                  Write-Host "🚫 停止执行：只有已关闭的PR才能触发Release构建"
                  Write-Host "   请等待PR被合并后再重新触发构建"
                  Write-Host "##vso[task.logissue type=error]Pipeline stopped: PR is not closed"
                  Write-Host "##vso[task.complete result=Failed]"
                  exit 1
              }
              
              if (-not $prMerged) {
                  Write-Host "❌ GATE FAILED: PR已关闭但未合并"
                  Write-Host "   PR状态: closed"
                  Write-Host "   合并状态: $prMerged"
                  Write-Host ""
                  Write-Host "🚫 停止执行：只有成功合并的PR才能触发Release构建"
                  Write-Host "   该PR可能被拒绝或手动关闭，而非合并"
                  Write-Host "##vso[task.logissue type=error]Pipeline stopped: PR was closed but not merged"
                  Write-Host "##vso[task.complete result=Failed]"
                  exit 1
              }
              
              Write-Host "🎉 GitHub PR合并状态检查通过！"
              Write-Host "   ✅ PR状态: closed"
              Write-Host "   ✅ 合并状态: merged = $prMerged"
              Write-Host "   ✅ 合并时间: $prMergedAt"
              Write-Host ""
              Write-Host "✨ 允许继续执行构建和Release流程..."
              Write-Host "========================================"
              
          } catch {
              Write-Host "❌ GATE FAILED: 无法检查GitHub PR状态"
              Write-Host "   错误信息: $($_.Exception.Message)"
              Write-Host ""
              Write-Host "💡 故障排除建议："
              Write-Host "   1. 检查 GH_TOKEN 是否正确配置"
              Write-Host "   2. 检查 GitHub PR编号是否有效: $githubPrNumber"
              Write-Host "   3. 检查网络连接到 api.github.com"
              Write-Host ""
              Write-Host "🚫 停止执行：无法验证PR合并状态"
              Write-Host "##vso[task.logissue type=error]Pipeline stopped: Cannot verify GitHub PR merge status"
              Write-Host "##vso[task.complete result=Failed]"
              exit 1
          }
      env:
        GH_TOKEN: $(GH_TOKEN)
      # 支持两种构建类型：PR构建 或 master分支的合并后构建
      condition: or(eq(variables['Build.Reason'], 'PullRequest'), and(eq(variables['Build.Reason'], 'IndividualCI'), eq(variables['Build.SourceBranch'], 'refs/heads/master')))

    # 🔧 设置版本号 (读取 PackageVersion + BuildId)
    - task: PowerShell@2
      displayName: 'Set Version from PackageVersion'
      inputs:
        targetType: 'inline'
        script: |
          # 读取 NCF.Template.csproj 中的 PackageVersion
          $csprojPath = "src/NCF.Template.csproj"
          
          if (Test-Path $csprojPath) {
              Write-Host "Reading PackageVersion from: $csprojPath"
              [xml]$csproj = Get-Content $csprojPath
              
              # 使用 XPath 选择第一个 PackageVersion 节点，避免数组问题
              $packageVersionNode = $csproj.SelectSingleNode("//PackageVersion")
              
              if ($packageVersionNode -and $packageVersionNode.InnerText) {
                  $packageVersion = $packageVersionNode.InnerText.Trim()
                  Write-Host "Found PackageVersion: $packageVersion"
                  
                  # 构建版本字符串
                  $buildId = "$(buildId)".Trim()
                  $fullVersion = "v$packageVersion-build$buildId"
                  $fileVersion = "$packageVersion-build$buildId"  # 用于文件名，不含 'v' 前缀
                  
                  Write-Host "Debug: packageVersion = '$packageVersion'"
                  Write-Host "Debug: buildId = '$buildId'"
                  Write-Host "Setting full version: $fullVersion"
                  Write-Host "Setting file version: $fileVersion"
                  
                  # 设置 pipeline 变量 (使用专用前缀避免与系统变量冲突)
                  Write-Host "##vso[task.setvariable variable=githubReleaseTag]$fullVersion"
                  Write-Host "##vso[task.setvariable variable=githubFileVersion]$fileVersion"
                  Write-Host "##vso[task.setvariable variable=ncfPackageVersion]$packageVersion"
                  
                  # 显示版本信息
                  Write-Host ""
                  Write-Host "=== Version Information ==="
                  Write-Host "Build ID: $buildId"
                  Write-Host "Package Version: $packageVersion"
                  Write-Host "Full Version Tag: $fullVersion"
                  Write-Host "File Version: $fileVersion"
                  Write-Host "=========================="
              } else {
                  Write-Host "❌ PackageVersion not found in $csprojPath"
                  # 备用方案：使用构建ID
                  $buildId = "$(buildId)".Trim()
                  $fallbackVersion = "v1.0.0-build$buildId"
                  $fallbackFileVersion = "1.0.0-build$buildId"
                  $fallbackPackageVersion = "1.0.0"
                  
                  Write-Host "Using fallback version: $fallbackVersion"
                  Write-Host "##vso[task.setvariable variable=githubReleaseTag]$fallbackVersion"
                  Write-Host "##vso[task.setvariable variable=githubFileVersion]$fallbackFileVersion"
                  Write-Host "##vso[task.setvariable variable=ncfPackageVersion]$fallbackPackageVersion"
                  
                  # 显示版本信息
                  Write-Host ""
                  Write-Host "=== Version Information (Fallback) ==="
                  Write-Host "Build ID: $buildId"
                  Write-Host "Package Version: $fallbackPackageVersion"
                  Write-Host "Full Version Tag: $fallbackVersion"
                  Write-Host "File Version: $fallbackFileVersion"
                  Write-Host "=========================="
              }
          } else {
              Write-Host "❌ File not found: $csprojPath"
              # 备用方案：使用构建ID
              $buildId = "$(buildId)".Trim()
              $fallbackVersion = "v1.0.0-build$buildId"
              $fallbackFileVersion = "1.0.0-build$buildId"
              $fallbackPackageVersion = "1.0.0"
              
              Write-Host "Using fallback version: $fallbackVersion"
              Write-Host "##vso[task.setvariable variable=githubReleaseTag]$fallbackVersion"
              Write-Host "##vso[task.setvariable variable=githubFileVersion]$fallbackFileVersion"
              Write-Host "##vso[task.setvariable variable=ncfPackageVersion]$fallbackPackageVersion"
              
              # 显示版本信息
              Write-Host ""
              Write-Host "=== Version Information (File Not Found) ==="
              Write-Host "Build ID: $buildId"
              Write-Host "Package Version: $fallbackPackageVersion"
              Write-Host "Full Version Tag: $fallbackVersion"
              Write-Host "File Version: $fallbackFileVersion"
              Write-Host "=========================="
          }


    # 🔧 验证 GitHub CLI
    - task: PowerShell@2
      displayName: 'Verify GitHub CLI'
      inputs:
        targetType: 'inline'
        script: |
          # 尝试多种方式查找和验证 GitHub CLI
          try {
              Write-Host "Attempting to verify GitHub CLI installation..."
              
              # 方法1: 直接调用 gh
              $ghVersion = gh --version 2>$null
              if ($ghVersion) {
                  Write-Host "✅ GitHub CLI found and working:"
                  Write-Host $ghVersion
              } else {
                  throw "Direct gh command failed"
              }
          } catch {
              try {
                  # 方法2: 尝试常见安装路径
                  $commonPaths = @(
                      "${env:ProgramFiles}\GitHub CLI\gh.exe",
                      "${env:ProgramFiles(x86)}\GitHub CLI\gh.exe",
                      "${env:LOCALAPPDATA}\Programs\GitHub CLI\gh.exe",
                      "C:\Program Files\GitHub CLI\gh.exe",
                      "C:\Program Files (x86)\GitHub CLI\gh.exe"
                  )
                  
                  $foundPath = $null
                  foreach ($path in $commonPaths) {
                      if (Test-Path $path) {
                          $foundPath = $path
                          break
                      }
                  }
                  
                  if ($foundPath) {
                      Write-Host "✅ Found GitHub CLI at: $foundPath"
                      & "$foundPath" --version
                      # 添加到 PATH
                      $dirPath = Split-Path $foundPath -Parent
                      Write-Host "##vso[task.setvariable variable=PATH]${env:PATH};$dirPath"
                  } else {
                      Write-Host "❌ GitHub CLI not found in common locations"
                      Write-Host "Available paths checked:"
                      $commonPaths | ForEach-Object { Write-Host "  - $_" }
                      throw "GitHub CLI not found"
                  }
              } catch {
                  Write-Host "⚠️  GitHub CLI verification failed, but continuing..."
                  Write-Host "##vso[task.logissue type=warning]GitHub CLI verification failed but build continues"
              }
          }

    # 🔧 设置环境变量
    - task: PowerShell@2
      displayName: 'Setup Environment'
      inputs:
        targetType: 'inline'
        script: |
          # 设置 GitHub token
          $env:GH_TOKEN = "$(GH_TOKEN)"
          Write-Host "##vso[task.setvariable variable=GH_TOKEN;issecret=true]$(GH_TOKEN)"
          
          # 验证 GitHub 认证
          gh auth status

          # ===================================================================
      # 🚀 发布流程开始 (简化逻辑：所有检查在Release步骤内部完成)
      # 1️⃣ 构建信息预览 → 2️⃣ 多平台构建 → 3️⃣ GitHub Release (内置条件检查) → 4️⃣ NuGet 发布 → 5️⃣ Web 站点发布
      # ===================================================================

        # 🔍 构建信息预览 (快速了解构建上下文)
    - task: PowerShell@2
      name: 'BuildInfo'
      displayName: '🔍 Build Information Preview'
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "========================================"
          Write-Host "🔍 BUILD INFORMATION PREVIEW"
          Write-Host "========================================"
          Write-Host ""
          
          # 显示基本构建信息
          $buildReason = $env:BUILD_REASON
          $buildRequestedFor = $env:BUILD_REQUESTEDFOR
          $sourceVersionAuthor = $env:BUILD_SOURCEVERSIONAUTHOR
          
          Write-Host "=== Build Context ==="
          Write-Host "Build.Reason: $buildReason"
          Write-Host "Build.RequestedFor: '$buildRequestedFor'"
          Write-Host "Build.SourceVersionAuthor: '$sourceVersionAuthor'"
          Write-Host "Build.SourceBranch: $env:BUILD_SOURCEBRANCH"
          Write-Host ""
          
          # 显示Release相关信息（仅供参考）
          Write-Host "=== Release Information Preview ==="
          $isAuthorizedUser = ($buildRequestedFor -eq "JeffreySu") -or ($sourceVersionAuthor -eq "JeffreySu")
          Write-Host "Is Authorized for Release: $isAuthorizedUser"
          
          if ($buildReason -eq "PullRequest") {
              $releaseKeyword = $env:SYSTEM_PULLREQUEST_PULLREQUESTTITLE
              Write-Host "PR Title: '$releaseKeyword'"
          } else {
              try {
                  $releaseKeyword = git log -1 --pretty=format:"%s"
                  Write-Host "Latest Commit Message: '$releaseKeyword'"
              } catch {
                  Write-Host "Latest Commit Message: <Could not retrieve>"
              }
          }
          
          if (-not [string]::IsNullOrEmpty($releaseKeyword)) {
              $hasReleaseKeyword = $releaseKeyword.ToLower().Contains("[release]")
              Write-Host "Contains [Release] keyword: $hasReleaseKeyword"
          }
          
          Write-Host ""
          Write-Host "ℹ️  Note: Final release decision will be made in the GitHub Release step"
          Write-Host "========================================"
      env:
        BUILD_REASON: $(Build.Reason)
        BUILD_REQUESTEDFOR: $(Build.RequestedFor)
        BUILD_SOURCEVERSIONAUTHOR: $(Build.SourceVersionAuthor)
        SYSTEM_PULLREQUEST_PULLREQUESTTITLE: $(System.PullRequest.PullRequestTitle)
        BUILD_SOURCEBRANCH: $(Build.SourceBranch)
      # 支持两种构建类型：PR构建 或 master分支的合并后构建
      condition: or(eq(variables['Build.Reason'], 'PullRequest'), and(eq(variables['Build.Reason'], 'IndividualCI'), eq(variables['Build.SourceBranch'], 'refs/heads/master')))

    # 🔍 调试构建信息 (早期信息收集)
    - task: PowerShell@2
      displayName: 'Debug Build Information'
      inputs:
        targetType: 'inline'
        script: |
          # 初始化变量 - 在脚本顶部定义一次
          $prTitle = $env:SYSTEM_PULLREQUEST_PULLREQUESTTITLE
          $buildRequestedFor = $env:BUILD_REQUESTEDFOR
          $buildRequestedForId = $env:BUILD_REQUESTEDFORID
          $buildRequestedForEmail = $env:BUILD_REQUESTEDFOREMAIL
          $sourceVersionAuthor = $env:BUILD_SOURCEVERSIONAUTHOR
          $isAuthorizedUser = ($buildRequestedFor -eq "JeffreySu") -or ($sourceVersionAuthor -eq "JeffreySu")
          
          # 调试：显示所有PR相关环境变量
          Write-Host ""
          Write-Host "=== PR Environment Variables Debug ==="
          Write-Host "SYSTEM_PULLREQUEST_PULLREQUESTTITLE: '$env:SYSTEM_PULLREQUEST_PULLREQUESTTITLE'"
          Write-Host "SYSTEM_PULLREQUEST_PULLREQUESTID: '$env:SYSTEM_PULLREQUEST_PULLREQUESTID'"
          Write-Host "SYSTEM_PULLREQUEST_PULLREQUESTNUMBER: '$env:SYSTEM_PULLREQUEST_PULLREQUESTNUMBER'"
          Write-Host "SYSTEM_PULLREQUEST_SOURCEBRANCH: '$env:SYSTEM_PULLREQUEST_SOURCEBRANCH'"
          Write-Host "SYSTEM_PULLREQUEST_TARGETBRANCH: '$env:SYSTEM_PULLREQUEST_TARGETBRANCH'"
          Write-Host "BUILD_REASON: '$env:BUILD_REASON'"
          Write-Host "BUILD_SOURCEBRANCH: '$env:BUILD_SOURCEBRANCH'"
          
          Write-Host "=== Build Debug Information ==="
          Write-Host "Build.Reason: $(Build.Reason)"
          Write-Host "Build.SourceBranch: $(Build.SourceBranch)"
          Write-Host "BUILD_REASON: '$env:BUILD_REASON'"
          Write-Host "BUILD_SOURCEBRANCH: '$env:BUILD_SOURCEBRANCH'"
          
          # 显示PR标题 - 重用预定义的变量
          if ([string]::IsNullOrEmpty($prTitle)) {
              Write-Host "System.PullRequest.PullRequestTitle: <NOT AVAILABLE - Not a PR build>"
          } else {
              Write-Host "System.PullRequest.PullRequestTitle: '$prTitle'"
          }
          
          Write-Host ""
          Write-Host "=== Commit Author Information ==="
          Write-Host "Build.RequestedFor: '$buildRequestedFor'"
          Write-Host "Build.RequestedForId: '$buildRequestedForId'"
          Write-Host "Build.RequestedForEmail: '$buildRequestedForEmail'"
          Write-Host "Build.SourceVersionAuthor: '$sourceVersionAuthor'"
          
          # 显示Release权限检查结果 - 重用预定义的变量
          Write-Host "Is Authorized for Release: $isAuthorizedUser"
          if ($isAuthorizedUser) {
              Write-Host "✅ User is authorized to create releases"
          } else {
              Write-Host "❌ User is NOT authorized to create releases (only JeffreySu can create releases)"
          }
          
          # 显示构建预览结果
          Write-Host ""
          Write-Host "=== Build Preview Results ==="
          Write-Host "Build information has been displayed in the previous step"
          Write-Host "Final release decision will be made in the GitHub Release step"
          
          Write-Host "=============================="

    # ✅ 多平台构建 (为潜在的Release或常规使用生成产物)
    - task: PowerShell@2
      displayName: '🔨 Build Multiple Platforms (Generate All Artifacts)'
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "========================================"
          Write-Host "🔨 MULTI-PLATFORM BUILD"
          Write-Host "========================================"
          Write-Host ""
          
          Write-Host "=== Build Strategy ==="
          Write-Host "Building all platforms for potential release or standard use"
          Write-Host ""
          
          Write-Host "🏗️  MULTI-PLATFORM BUILD: 构建所有平台"
          Write-Host "   Purpose: 生成完整的构建产物"
          Write-Host "   Release decision: 将在GitHub Release步骤中确定"
          $buildPurpose = "Multi-Platform Artifacts"
          
          Write-Host "Build Purpose: $buildPurpose"
          Write-Host "Target Project: $(webProject)"
          Write-Host "Build Configuration: $(buildConfiguration)"
          Write-Host ""
          
          Write-Host "=== Multi-Platform Publishing ==="
          Write-Host "🖥️  Publishing Windows x64 platform..."
          dotnet publish $(webProject) --configuration $(buildConfiguration) --runtime win-x64 --output $(Build.ArtifactStagingDirectory)/win-x64

          Write-Host "💻 Publishing Windows ARM64 platform (Surface Pro X, etc.)..."
          dotnet publish $(webProject) --configuration $(buildConfiguration) --runtime win-arm64 --output $(Build.ArtifactStagingDirectory)/win-arm64

          Write-Host "🐧 Publishing Linux x64 platform..."
          dotnet publish $(webProject) --configuration $(buildConfiguration) --runtime linux-x64 --output $(Build.ArtifactStagingDirectory)/linux-x64

          Write-Host "🔧 Publishing Linux ARM64 platform..."
          dotnet publish $(webProject) --configuration $(buildConfiguration) --runtime linux-arm64 --output $(Build.ArtifactStagingDirectory)/linux-arm64

          Write-Host "🍎 Publishing macOS x64 platform (Intel/Rosetta)..."
          dotnet publish $(webProject) --configuration $(buildConfiguration) --runtime osx-x64 --output $(Build.ArtifactStagingDirectory)/osx-x64

          Write-Host "🚀 Publishing macOS ARM64 platform (Apple Silicon)..."
          dotnet publish $(webProject) --configuration $(buildConfiguration) --runtime osx-arm64 --output $(Build.ArtifactStagingDirectory)/osx-arm64
          
          Write-Host ""
          Write-Host "✅ All platform builds completed successfully"
          Write-Host "   Output Directory: $(Build.ArtifactStagingDirectory)"
          Write-Host "   Build Purpose: $buildPurpose"
          Write-Host "========================================"

    # 🟢 缓存 NuGet 及依赖项
    - task: Cache@2
      inputs:
        key: 'nuget | "$(Agent.OS)" | **/*.csproj'
        path: '$(NUGET_PACKAGES)'
        restoreKeys: 'nuget'
      displayName: 'Cache NuGet Packages'

    # 🟢 缓存 Aspire Workload
    - task: Cache@2
      inputs:
        key: 'aspire-workload | "$(Agent.OS)"'
        path: '~/.dotnet'
        restoreKeys: 'aspire-workload'
      displayName: 'Cache Aspire Workload'

    # 🟢 缓存 NuGet 工具
    - task: Cache@2
      inputs:
        key: 'nuget-tool | "$(Agent.OS)"'
        path: 'C:\ProgramData\nuget'
        restoreKeys: 'nuget-tool'
      displayName: 'Cache NuGet Tool'

    # ✅ 仅当缓存未命中时安装 Aspire Workload
    - script: |
        dotnet workload list | findstr /C:"aspire" || dotnet workload install aspire
      displayName: 'Check & Install Aspire Workload'
      condition: ne(variables['CACHE_RESTORED'], 'true')

    # ✅ 使用缓存的 NuGet 版本
    - task: NuGetToolInstaller@1
      displayName: 'Use Cached NuGet 6.3.0'
      inputs:
        versionSpec: '6.3.0'

    - script: |
        nuget sources remove -name nuget.org
      displayName: 'Remove Existing NuGet Source'

    - script: |
        dotnet nuget add source https://api.nuget.org/v3/index.json -n nuget.org
      displayName: 'Add NuGet Source'

    # ✅ 恢复 NuGet 依赖
    - task: NuGetCommand@2
      inputs:
        restoreSolution: '$(solution)'

    # ✅ 解决方案构建
    - task: VSBuild@1
      inputs:
        solution: '$(solution)'
        msbuildArgs: '/p:DeployOnBuild=true /p:WebPublishMethod=Package /p:PackageAsSingleFile=true /p:SkipInvalidConfigurations=true /p:DesktopBuildPackageLocation="$(build.artifactStagingDirectory)\WebApp.zip" /p:DeployIisAppPath="Default Web Site"'
        platform: 'Any CPU'
        configuration: '$(buildConfiguration)'

    # ✅ 恢复 Template 依赖
    - task: NuGetCommand@2
      inputs:
        restoreSolution: '$(templateBuild)'

    # ✅ 构建 Template 解决方案
    - task: VSBuild@1
      inputs:
        solution: '$(templateBuild)'
        msbuildArgs: ''
        platform: 'Any CPU'
        configuration: '$(buildConfiguration)'



    # 🚀 创建 GitHub Release (基于早期检查结果)
    - task: PowerShell@2
      displayName: '🚀 Create GitHub Release (Conditional on Early Check)'
      inputs:
        targetType: 'inline'
        script: |
          try {
              Write-Host "========================================"
              Write-Host "🚀 GITHUB RELEASE CREATION"
              Write-Host "========================================"
              Write-Host ""
              
              # 重新执行Release条件检查（避免Azure DevOps条件评估问题）
              Write-Host "=== Release Condition Verification ==="
              
              # 1. 用户权限检查
              $buildReason = $env:BUILD_REASON
              $buildRequestedFor = $env:BUILD_REQUESTEDFOR
              $sourceVersionAuthor = $env:BUILD_SOURCEVERSIONAUTHOR
              $isAuthorizedUser = ($buildRequestedFor -eq "JeffreySu") -or ($sourceVersionAuthor -eq "JeffreySu")
              
              Write-Host "Build.RequestedFor: '$buildRequestedFor'"
              Write-Host "Build.SourceVersionAuthor: '$sourceVersionAuthor'"
              Write-Host "Is Authorized User: $isAuthorizedUser"
              
              if (-not $isAuthorizedUser) {
                  Write-Host ""
                  Write-Host "❌ AUTHORIZATION FAILED: Only JeffreySu can create releases"
                  Write-Host "   Current user: '$buildRequestedFor' / '$sourceVersionAuthor'"
                  Write-Host "   Required user: 'JeffreySu'"
                  Write-Host ""
                  Write-Host "⏭️  SKIPPING GITHUB RELEASE CREATION"
                  Write-Host "ℹ️  Build will continue with other steps (artifacts, NuGet, etc.)"
                  Write-Host "========================================"
                  return
              }
              
              Write-Host "✅ User authorization passed"
              
              # 2. Release关键字检查
              Write-Host ""
              Write-Host "=== Release Keyword Check ==="
              if ($buildReason -eq "PullRequest") {
                  $releaseKeyword = $env:SYSTEM_PULLREQUEST_PULLREQUESTTITLE
                  $releaseKeywordSource = "PR标题"
              } else {
                  try {
                      $releaseKeyword = git log -1 --pretty=format:"%s"
                      $releaseKeywordSource = "Commit Message"
                  } catch {
                      $releaseKeyword = ""
                      $releaseKeywordSource = "Commit Message"
                  }
              }
              
              Write-Host "${releaseKeywordSource}: '$releaseKeyword'"
              
              if ([string]::IsNullOrEmpty($releaseKeyword)) {
                  Write-Host ""
                  Write-Host "❌ RELEASE KEYWORD CHECK FAILED: 无法获取${releaseKeywordSource}"
                  Write-Host ""
                  Write-Host "⏭️  SKIPPING GITHUB RELEASE CREATION"
                  Write-Host "ℹ️  Build will continue with other steps (artifacts, NuGet, etc.)"
                  Write-Host "========================================"
                  return
              }
              
              if (-not ($releaseKeyword.ToLower().Contains("[release]"))) {
                  Write-Host ""
                  Write-Host "❌ RELEASE KEYWORD CHECK FAILED: ${releaseKeywordSource} does not contain [Release]"
                  Write-Host "   Current ${releaseKeywordSource}: '$releaseKeyword'"
                  Write-Host "   Required: Must contain '[Release]' (case insensitive)"
                  Write-Host "   Examples: '[Release] v1.0', 'Bug fixes [RELEASE]', '[release] New features'"
                  Write-Host ""
                  Write-Host "⏭️  SKIPPING GITHUB RELEASE CREATION"
                  Write-Host "ℹ️  Build will continue with other steps (artifacts, NuGet, etc.)"
                  Write-Host "========================================"
                  return
              }
              
              Write-Host "✅ ${releaseKeywordSource} contains [Release] keyword"
              
              # 3. 所有条件满足
              Write-Host ""
              Write-Host "🎉 ALL RELEASE CONDITIONS SATISFIED!"
              Write-Host "   ✅ User: JeffreySu"
              Write-Host "   ✅ Keyword: [Release] found in ${releaseKeywordSource}"
              Write-Host "   ✅ Build Type: $buildReason"
              Write-Host ""
              Write-Host "🚀 Proceeding with GitHub Release creation..."
              Write-Host ""
              Write-Host "=== Release Information ==="
              Write-Host "Release Tag: $(githubReleaseTag)"
              Write-Host "File Version: $(githubFileVersion)"
              Write-Host "Package Version: $(ncfPackageVersion)"
              Write-Host "Build ID: $(buildId)"
              
              Write-Host "Creating GitHub Release version $(githubReleaseTag)"
              
              # 确保 GitHub CLI 可用
              try {
                  $ghVersion = gh --version 2>$null
                  if ($ghVersion) {
                      Write-Host "Using GitHub CLI: $ghVersion"
                  } else {
                      throw "GitHub CLI not accessible"
                  }
              } catch {
                  Write-Host "⚠️ GitHub CLI not found, attempting to locate..."
                  $commonPaths = @(
                      "${env:ProgramFiles}\GitHub CLI\gh.exe",
                      "${env:ProgramFiles(x86)}\GitHub CLI\gh.exe",
                      "C:\Program Files\GitHub CLI\gh.exe"
                  )
                  
                  $ghPath = $null
                  foreach ($path in $commonPaths) {
                      if (Test-Path $path) {
                          $ghPath = $path
                          break
                      }
                  }
                  
                  if ($ghPath) {
                      Write-Host "Found GitHub CLI at: $ghPath"
                      Set-Alias -Name gh -Value $ghPath -Scope Global
                  } else {
                      throw "GitHub CLI not found in any common location"
                  }
              }
              
              # 添加 macOS 启动脚本到发布包 (转换为Unix行结束符)
              Write-Host "Adding macOS startup script to release packages..."
              if (Test-Path "start-ncf-macos.sh") {
                  # 读取文件内容并转换行结束符为 LF (Unix格式)
                  $scriptContent = Get-Content "start-ncf-macos.sh" -Raw
                  $unixScript = $scriptContent -replace "`r`n", "`n" -replace "`r", "`n"
                  
                  # 写入到 macOS 发布目录，确保使用 UTF-8 无 BOM 编码
                  [System.IO.File]::WriteAllText("$(Build.ArtifactStagingDirectory)/osx-x64/start-ncf-macos.sh", $unixScript, [System.Text.UTF8Encoding]::new($false))
                  [System.IO.File]::WriteAllText("$(Build.ArtifactStagingDirectory)/osx-arm64/start-ncf-macos.sh", $unixScript, [System.Text.UTF8Encoding]::new($false))
                  
                  Write-Host "✅ macOS startup script added with Unix line endings"
              } else {
                  Write-Host "⚠️  Warning: start-ncf-macos.sh not found in source directory"
              }

              # 添加 macOS 使用指南 (确保正确编码)
              if (Test-Path "MACOS_USAGE_GUIDE.md") {
                  # 读取文件内容并转换行结束符为 LF (Unix格式)
                  $guideContent = Get-Content "MACOS_USAGE_GUIDE.md" -Raw
                  $unixGuide = $guideContent -replace "`r`n", "`n" -replace "`r", "`n"
                  
                  # 写入到 macOS 发布目录，确保使用 UTF-8 无 BOM 编码
                  [System.IO.File]::WriteAllText("$(Build.ArtifactStagingDirectory)/osx-x64/MACOS_USAGE_GUIDE.md", $unixGuide, [System.Text.UTF8Encoding]::new($false))
                  [System.IO.File]::WriteAllText("$(Build.ArtifactStagingDirectory)/osx-arm64/MACOS_USAGE_GUIDE.md", $unixGuide, [System.Text.UTF8Encoding]::new($false))
                  
                  Write-Host "✅ macOS usage guide added with Unix line endings"
              }

              # 压缩发布文件以减少asset数量
              Write-Host "Compressing release files..."
              Compress-Archive -Path "$(Build.ArtifactStagingDirectory)/win-x64/*" -DestinationPath "$(Build.ArtifactStagingDirectory)/ncf-win-x64-$(githubFileVersion).zip" -Force
              Compress-Archive -Path "$(Build.ArtifactStagingDirectory)/win-arm64/*" -DestinationPath "$(Build.ArtifactStagingDirectory)/ncf-win-arm64-$(githubFileVersion).zip" -Force
              Compress-Archive -Path "$(Build.ArtifactStagingDirectory)/linux-x64/*" -DestinationPath "$(Build.ArtifactStagingDirectory)/ncf-linux-x64-$(githubFileVersion).zip" -Force
              Compress-Archive -Path "$(Build.ArtifactStagingDirectory)/linux-arm64/*" -DestinationPath "$(Build.ArtifactStagingDirectory)/ncf-linux-arm64-$(githubFileVersion).zip" -Force
              Compress-Archive -Path "$(Build.ArtifactStagingDirectory)/osx-x64/*" -DestinationPath "$(Build.ArtifactStagingDirectory)/ncf-osx-x64-$(githubFileVersion).zip" -Force
              Compress-Archive -Path "$(Build.ArtifactStagingDirectory)/osx-arm64/*" -DestinationPath "$(Build.ArtifactStagingDirectory)/ncf-osx-arm64-$(githubFileVersion).zip" -Force
              
              # 验证文件存在
              $assetFiles = @(
                  "$(Build.ArtifactStagingDirectory)/ncf-win-x64-$(githubFileVersion).zip",
                  "$(Build.ArtifactStagingDirectory)/ncf-win-arm64-$(githubFileVersion).zip",
                  "$(Build.ArtifactStagingDirectory)/ncf-linux-x64-$(githubFileVersion).zip",
                  "$(Build.ArtifactStagingDirectory)/ncf-linux-arm64-$(githubFileVersion).zip",
                  "$(Build.ArtifactStagingDirectory)/ncf-osx-x64-$(githubFileVersion).zip",
                  "$(Build.ArtifactStagingDirectory)/ncf-osx-arm64-$(githubFileVersion).zip"
              )
              
              foreach ($file in $assetFiles) {
                  if (Test-Path $file) {
                      $size = (Get-Item $file).Length / 1MB
                      Write-Host "✅ Asset ready: $(Split-Path $file -Leaf) ($([math]::Round($size, 2)) MB)"
                  } else {
                      Write-Host "❌ Missing asset: $file"
                  }
              }
              
              # 创建 release
              $releaseNotes = @"
          ## 🚀 NCF Release $(githubReleaseTag)
          
          ### 📋 版本信息
          - **Package Version**: $(ncfPackageVersion)
          - **Build ID**: $(buildId)
          - **Full Version**: $(githubReleaseTag)
          
          ### 📦 平台支持
          - **Windows x64** - 适用于传统 Windows 10/11 (Intel/AMD 64位)
          - **Windows ARM64** - 适用于 Surface Pro X, Surface Laptop 5/6 等 ARM 架构设备
          - **Linux x64** - 适用于 Linux (Intel/AMD 64位)
          - **Linux ARM64** - 适用于 Linux (ARM64，如树莓派4+)
          - **macOS x64** - 适用于 Intel Mac 或 Apple Silicon Mac (通过 Rosetta 2)
          - **macOS ARM64** - 适用于 Apple Silicon Mac (M1/M2/M3/M4 原生)
          
          ### 📋 使用指南
          **Windows 用户请注意**：
          - 大部分 Windows 设备使用 `ncf-win-x64-$(githubFileVersion).zip`
          - Surface Pro X 等 ARM 设备使用 `ncf-win-arm64-$(githubFileVersion).zip`
          
          **macOS 用户请注意**：
          - M1/M2/M3/M4 Mac 用户推荐下载 `ncf-osx-arm64-$(githubFileVersion).zip` (原生性能更好)
          - Intel Mac 用户下载 `ncf-osx-x64-$(githubFileVersion).zip`
          - **🆕 自动化启动脚本**：包含优化的 `start-ncf-macos.sh`
            - ✅ 自动处理 macOS 安全权限问题
            - ✅ 自动创建数据库目录
            - ✅ 已修复行结束符问题，确保在所有 macOS 版本上正常运行
            - 一键启动：解压后运行 `./start-ncf-macos.sh`
          - 手动启动：`dotnet Senparc.Web.dll`
          - 完整使用指南请查看 `MACOS_USAGE_GUIDE.md`
          
          ### 📅 构建信息
          - 构建号: $(Build.BuildNumber)
          - 源分支: $(Build.SourceBranchName)
          - 提交: $(Build.SourceVersion)
          - 发布时间: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss UTC')
          - PR 标题: $env:SYSTEM_PULLREQUEST_PULLREQUESTTITLE
          
          ### 📋 变更
          本版本基于 NCF Template v$(ncfPackageVersion)，详细变更请查看：
          - [PackageReleaseNotes](https://github.com/NeuCharFramework/NCF/blob/master/src/NCF.Template.csproj)
          - [提交历史](https://github.com/NeuCharFramework/NCF/commits/$(Build.SourceBranchName))
          
          ---
          
          > **📋 开发者提示**: 此Release通过包含 `[Release]` 标签的PR自动创建。
          > 要创建新的Release，请确保PR标题包含 `[Release]` (不区分大小写)。
          "@
              
              Write-Host "Creating GitHub Release..."
              gh release create "$(githubReleaseTag)" `
                  --target "$(Build.SourceVersion)" `
                  --title "NCF Release $(githubReleaseTag)" `
                  --notes $releaseNotes `
                  "$(Build.ArtifactStagingDirectory)/ncf-win-x64-$(githubFileVersion).zip" `
                  "$(Build.ArtifactStagingDirectory)/ncf-win-arm64-$(githubFileVersion).zip" `
                  "$(Build.ArtifactStagingDirectory)/ncf-linux-x64-$(githubFileVersion).zip" `
                  "$(Build.ArtifactStagingDirectory)/ncf-linux-arm64-$(githubFileVersion).zip" `
                  "$(Build.ArtifactStagingDirectory)/ncf-osx-x64-$(githubFileVersion).zip" `
                  "$(Build.ArtifactStagingDirectory)/ncf-osx-arm64-$(githubFileVersion).zip"
                  
              Write-Host "✅ GitHub Release created successfully"
          } catch {
              Write-Host "❌ Failed to create GitHub Release: $_"
              Write-Host "##vso[task.logissue type=warning]GitHub Release creation failed but build continues"
          }
      env:
        GH_TOKEN: $(GH_TOKEN)
        SYSTEM_ACCESSTOKEN: $(System.AccessToken)
        BUILD_REASON: $(Build.Reason)
        BUILD_REQUESTEDFOR: $(Build.RequestedFor)
        BUILD_SOURCEVERSIONAUTHOR: $(Build.SourceVersionAuthor)
        SYSTEM_PULLREQUEST_PULLREQUESTTITLE: $(System.PullRequest.PullRequestTitle)
      # 简化条件：只检查基本构建类型，具体逻辑在脚本内部处理
      # 这样避免Azure DevOps条件评估的复杂性问题
      condition: and(succeeded(), or(eq(variables['Build.Reason'], 'PullRequest'), and(eq(variables['Build.Reason'], 'IndividualCI'), eq(variables['Build.SourceBranch'], 'refs/heads/master'))))

    # ✅ 推送 NuGet 包 (发布流程第3步：在 GitHub Release 之后执行)
    - task: NuGetCommand@2
      displayName: '📦 Push NuGet Package (Step 3)'
      inputs:
        command: push
        packagesToPush: '**/Senparc.NCF.Template.*.nupkg'
        nuGetFeedType: external
        publishFeedCredentials: 'nuget-jeffrey-full-key'
      continueOnError: true
      condition: succeededOrFailed()

    # ✅ 发布构建产物 (发布流程第4步：Web 站点发布 - 最终步骤)
    - task: PublishBuildArtifacts@1
      displayName: '🌐 Publish Web Artifacts (Step 4 - Final)'
      inputs:
        PathtoPublish: '$(Build.ArtifactStagingDirectory)'
        ArtifactName: 'sample'